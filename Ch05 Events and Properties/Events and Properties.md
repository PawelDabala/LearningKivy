# Events and Properties
## Event-Driven Applications
Most GUI applications are event-driven applications (EDA). Once a
graphic interface is displayed, an application enters a main
loop waiting for different events to happen. Each iteration of the main
loop is called a time **frame** in Kivy documents. If an event happens, 
an application dispatches the event to its handlers, also called callbacks.
Callbacks register to the application to tell event dispatcher which 
events that they are interested. The registration process bind a 
callback to an event. A key function of a GUI framework is to register 
callbacks, monitor events, generate/transform events,  and dispatch events. 
The following diagram from [Kivy document site](http://kivy.org/docs/guide/events.html)
depicts the event process.

![Kivy Event Process](http://kivy.org/docs/_images/Events.png)

There are many events that may be triggered in an application's lifecycle. 
Some events like keyboard input, mouse click, screen touch etc are 
from a GUI user interactions. Some events are generated by systems 
or even a GUI application itself. System events include a 
network disconnection, alarm timeout, filesystem activities etc. 
An application can generate or trigger events. For example, 
an application generates `on_start`, `on_stop`,
`on_pause`, and `on_resume` events when it starts, stops, pauses or 
resumes from a pause. Additionally, when a widget changes its 
position or size, it raises an event.

In Kivy, events are grouped into three categories based on the
sources of events:

* Application and user-defined events: application lifecycle event,
clock timeout etc.
* Property event: this is an event fired when a 
widget's property changes. For example, a position or a size change.
* Widget-defined event: this includes all other events such as
button pressed, screen touch done etc.

Because a widget knows all its property changes, it uses a 
so-called observer pattern to bind and dispatch its property events. 
Widget-defined events use a `EventDispatcher` class to 
bind and dispatch these events. The basic usage pattern 
of the two event types is the same: we bind a callback to an event. 
When the event fires, the callback is executed. 

## Scheduling an Event
A commonly used user-defined event is a clock event. For example,  
the call `Clock.schedule_interval(my_callback, 1/30.0)` schedules
an event that fires 30 times a second. When it fires, it calls 
`my_callback` function. 

Following is an example from [Kivy events doc](http://kivy.org/docs/guide/events.html).

```python
count = 0
def my_callback(dt):
    global count
    count += 1
    if count == 10:
        print 'Last call of my callback, bye bye !'
        return False
    print 'My callback is called'
Clock.schedule_interval(my_callback, 1 / 30.0)
```

A full sample can be found in [./source/0501](./source/0501). 
In the above code, the event is unscheduled when its handler returns `False`.
Another way to unschedule it is to use `Clock.unschedule(my_callback)`

To fire an event only once, use `Clock.schedule_once` method.  It takes
two arguments: the first is an event handler; the second is a timer that
the event fires. If the time is a positive number, it calls the event
handler in the specified number of seconds. If it is 0, it fires in the 
next event loop (frame). If it is `-1`, it calls the event handler
in the current event loop.

If schedule an event only once, use 
`Clock.schedule_once(my_callback, num_seconds)`. It fires the event in
the specified number of seconds. This is often used to change a 
schedule in re-schedule event in each call. For example: 
 
```python
def my_callback(dt):
    print 'My callback is called !'
    Clock.schedule_once(my_callback, 1)
Clock.schedule_once(my_callback, 1)
```

If the purpose is to trigger an event only once in the next frame, use
the following code: 

```python
trigger = Clock.create_trigger(my_callback)
# later
trigger()
```

## The `Property` Class
A special kind of "event" sources is a widget property. A widget 
usually has many properties such as its position, size, or text. 
In many cases we want to be notified 
when those values change. For example, when a widget changes it position 
to a special zone, we want to change its color. Because this is 
a very common requirement in a GUI application, Kivy defines a 
`Property` class that implements the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern).
Similar to an event, a `Property` instance maintains a list of observers 
-- usually an observer is a callback function. When the value of 
a `Property` instance changes, it calls its observers with two parameters: 
the `Property`'s widget instance and the changed value. 

A property of a widget is an instance of the `Property` class. 
It is not the Python built-in `property` class that 
is often used with the `@property` decorator. 
The `Property` class is a Python descriptor that implements the 
observer pattern and other special features such as value validation. 

The `Property` class has the following event-related methods: 

* `bind()`: bind a property event to one or more handlers, i.e., bind 
an observer to a value change event. 
* `unbind()`: unbind a handler.
* `dispatch()`: dispatch an event manually. Usually Kivy fires events 
automatically when something happens. But we can fire an event using
this method. 

### Property Classes
The `Property` class is the parent class for a number of type-specific 
property types. This class should not be directly instantiated.
The following are some common property classes that can be 
used to represent type-specific values, valid values and 
fire events when their values change. 

* `NumericProperty`: it represents an `int` or `float` value and a type. 
Default is 0 with a type of `px`. A `NumericProperty` value can be
initialized with a numeric number and a type. For example, 
`0.5`, `'5dp'`, and `(7.5, "sp")` are all valid values.
* `BoundedNumericProperty`: it represents a numeric value that has 
a minimum and/or a maximum bound. 
* `StringProperty`: it represents a string value. Default is an empty
string `''`.
* `ListProperty`: it represents a list. Default is an empty list. 
* `ObjectProperty`: it represents a Python object. It first an event
when it is assigned to a different Python object.
* `BooleanProperty`: it represents a boolean value.
* `OptionProperty`: it represents a string that must be from
a predefined list of strings. 
* `ReferenceListProperty`: it represents a tuple of other properties. 
The `pos` property of a widget is an instance of `ReferenceListProperty`. 
When you read the property, it returns a tuple of Python values. 
* `DictProperty`: it represents a dict. 

### Property Events
Use of property events involves fours steps: declare a property, 
bind a property change event, change a property value, 
and handle a property event. 

#### 1. Property Declaration
A Kivy property must be declared as a **class attribute**, 
not an instance attribute. A Kivy property is an instance 
of one of the above property classes. Following is a widget 
class ([./source/0502](./source/0502)) that has two properties: 

```python
class CustomBtn(Widget):
    pressed = ListProperty([0, 0])
    demo_prop = NumericProperty(0)
```

#### 2. Bind Property Change Event
There are two approaches to bind a property change event: 

* Inside a widget, define an instance method with a name `on_property_name`.
* Outside a widget, use the `bind` bind method. 

In the code in [./source/0501](./source/0501), an event 
handler is defined for each property using property names. 

```python
def on_pressed(self, instance, pos):
    print 'pressed at {pos}'.format(pos=pos)

def on_demo_prop(self, instance, value):
    print 'on_demo_prop value changed to {}'.format(value)
```

Outside the widget, the `bind` method of a widget is used to bind 
 
```python
cb.bind(pressed=self.btn_pressed)
cb.bind(demo_prop=self.demo_changed)
```

#### 3. Change a Property Value
In the code in [./source/0501](./source/0501), the above 
two properties are changed as when a `touch_down` event fires.
When a `touch_down` event fires, the `on_touch_down` handler 
is triggered. 

```python
def on_touch_down(self, touch):
    if self.collide_point(*touch.pos):
        self.pressed = touch.pos
        return True
    return super(CustomBtn, self).on_touch_down(touch)
```

If the touch down even is inside the `CustomBtn` widget, it 
sets the `pressed` property to the touch position.
  
The `demo_prop` is changed in event handler of the `pressed` 
property event: 

```python
self.cb.demo_prop += 1
```

A common use of property is to bind it to a widget such as a textbox, 
when the textbox value changes, the property change event fires. 

#### 4. Handle a Property Event
All handlers of a property change event are called when the 
property value changes. In the code example in [./source/0503](./source/0503),
a `touch_down` widget event triggers a number of property change events: 

* Two handlers of the `pressed` property change event
* Two handlers of the `demo_prop` property change event

## Event Dispatcher
All Kivy widget classes are subclasses of the `EventDispatcher` Class.
This class has the following event-related methods:

* `bind()`: bind a widget-defined event to one or more handlers
* `unbind()`: unbind one or more handlers.
* `register_event_type()`: register an event type.
* `unregister_event_types()`: unregister event types.
* `dispatch()`: dispatch (fire) an event. Usually Kivy fires events 
automatically when something happens. But we can fire an event too.
* `events()`: return all events in the class
* `get_property_observers()`: return a list of handlers bound to 
an event (a widget_defined event or a property event)

### How Event Dispatcher Works
The implementation of an event dispatcher is pretty simple. 
There are only two steps to define an event dispatcher: 

1. Register an event type. Event type name must start with the prefix `on_`.
2. Create a default handler method that has the same same as the event type.
This default handler is called when an event of its event type fires. 
If there is nothing to do in a default handler, the method can be an 
empty method as shown in the following example. 

An event fires by calling an event dispatcher's `dispatch()` method. 
To use an event, bind a callback to the event type defined
As shown in the above sample, binding can be done by either
calling `bind()` method or following the `on_event_type()`
method name convention.

The code in [./source/0504](./source/0504) is adapted from 
[Kivy events and properties guide](http://kivy.org/docs/guide/events.html). 

```python
class MyEventDispatcher(EventDispatcher):
    def __init__(self, **kwargs):
        self.register_event_type('on_test')
        super(MyEventDispatcher, self).__init__(**kwargs)

    def on_test(self, *args):
        pass


def my_callback(value, *args):
    print "Hello, I got an event!", args


class HelloWorldApp(App):
    pass

if __name__ == '__main__':

    ev = MyEventDispatcher()
    ev.bind(on_test=my_callback)
    ev.dispatch('on_test', 'test_message')

    HelloWorldApp().run()
```

## Widget Events
A widget is a subclass of `EventDispatcher`. Therefore it 
can bind event and dispatch event. A widget also has many properties 
that support binding and call callbacks when their values change.  

An event callback is usually called with one argument that is the widget itself. 
A property callback is usually called with two arguments: a widget and its
new property value. 

### A Custom Widget Event
The code in [./source/0505](./source/0505)
demonstrates a custom event type for a widget. 

```python
class MyWidget(Widget):
    def __init__(self, **kwargs):
        super(MyWidget, self).__init__(**kwargs)
        self.register_event_type('on_custom_event')

    def trigger_custom_event(self, *args):
        self.dispatch('on_custom_event', 'test message')

    def on_custom_event(self, *args):
        pass


def on_custom_callback(*args):
    print 'my on_custom_event is called with {}'.format(args)


class HelloWorldApp(App):
    def build(self):
        w = MyWidget()
        w.bind(on_custom_event=on_custom_callback)
        Clock.schedule_once(w.trigger_custom_event, 3)

        return w


if __name__ == '__main__':

    HelloWorldApp().run()
```

### A Widget Event Demo
Following is an example copied from [Kivy EventDispatcher API reference](http://kivy.org/docs/api-kivy.event.html#kivy.event.EventDispatcher).

```python
from kivy.uix.boxlayout import BoxLayout
from kivy.app import App
from kivy.uix.button import Button
from functools import partial


class DemoBox(BoxLayout):
    """
    This class demonstrates various techniques that can be used for binding to
    events. Although parts could me made more optimal, advanced Python concepts
    are avoided for the sake of readability and clarity.
    """
    def __init__(self, **kwargs):
        super(DemoBox, self).__init__(**kwargs)
        self.orientation = "vertical"

        # We start with binding to a normal event. The only argument
        # passed to the callback is the object which we have bound to.
        btn = Button(text="Normal binding to event")
        btn.bind(on_press=self.on_event)

        # Next, we bind to a standard property change event. This typically
        # passes 2 arguments: the object and the value
        btn2 = Button(text="Normal binding to a property change")
        btn2.bind(state=self.on_property)

        # Here we use anonymous functions (a.k.a lambdas) to perform binding.
        # Their advantage is that you can avoid declaring new functions i.e.
        # they offer a concise way to "redirect" callbacks.
        btn3 = Button(text="Using anonymous functions.")
        btn3.bind(on_press=lambda x: self.on_event(None))

        # You can also declare a function that accepts a variable number of
        # positional and keyword arguments and use introspection to determine
        # what is being passed in. This is very handy for debugging as well
        # as function re-use. Here, we use standard event binding to a function
        # that accepts optional positional and keyword arguments.
        btn4 = Button(text="Use a flexible function")
        btn4.bind(on_press=self.on_anything)

        # Lastly, we show how to use partial functions. They are sometimes
        # difficult to grasp, but provide a very flexible and powerful way to
        # reuse functions.
        btn5 = Button(text="Using partial functions. For hardcores.")
        btn5.bind(on_press=partial(self.on_anything, "1", "2", monthy="python"))

        for but in [btn, btn2, btn3, btn4, btn5]:
            self.add_widget(but)

    def on_event(self, obj):
        print("Typical event from", obj)

    def on_property(self, obj, value):
        print("Typical property change from", obj, "to", value)

    def on_anything(self, *args, **kwargs):
        print('The flexible function has *args of', str(args),
            "and **kwargs of", str(kwargs))


class DemoApp(App):
    def build(self):
        return DemoBox()

if __name__ == "__main__":
    DemoApp().run()
```




