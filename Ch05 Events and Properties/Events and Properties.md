# Events and Properties
## Event-Driven Applications
Most GUI applications are event-driven applications (EDA). Once a
graphic interface is displayed, an application enters a 
loop waiting for different events to happen. If an event happens, 
an application dispatches the event to its handlers, also called callbacks.
Callbacks register to the application to tell event dispatcher which 
events that they are interested. The registration process bind a 
callback to an event. A key function of a GUI framework is to register 
callbacks, monitor events, generate/transform events,  and dispatch events. 
The following diagram from [Kivy document site](http://kivy.org/docs/guide/events.html)
depicts the event process.

![Kivy Event Process](http://kivy.org/docs/_images/Events.png)

There are many events that may be triggered in  
an application's lifecycle. Some events like keyboard input, 
mouse click, screen touch etc are from a GUI user interactions. 
Some events are generated by systems or even a GUI application itself. 
System events include a network disconnection, alarm timeout, 
filesystem activities etc. An application can generate or trigger 
events. For example, an application generates `on_start`, `on_stop`,
`on_pause`, and `on_resume` events when it starts, stops, pauses or 
resumes from a pause. Additionally, when a widget changes its 
position or size, it raises an event.

In Kivy, events are grouped into two categories based on the
sources of events:

* Property event: this is an event fired when a 
widget's property changes. For example, a position or a size change.
* Widget-defined event: this includes all other events such as
button pressed, screen touch done, clock timeout, application
lifecycle status change etc.

Because a widget knows all its property changes, it uses a 
so-called observer pattern to bind and dispatch its property events. 
Widget-defined events use a `EventDispatcher` class to 
bind and dispatch these events. The basic usage pattern 
of the two event types is the same: we bind a callback to an event. 
When the event fires, the callback is executed. 
There are some differences between them that will be explained 
in the following sections. 

## The `Property` Class
A special kind of "event" sources is a widget property. A widget 
usually has many properties such as its position, size, or text. 
In many cases we want to be notified 
when those values change. For example, when a widget changes it position 
to a special zone, we want to change its color. Because this is 
a very common requirement in a GUI application, Kivy defines a 
`Property` class that implements the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern).
Similar to an event, a `Property` instance maintains a list of observers 
-- usually an observer is a callback function. When the value of 
a `Property` instance changes, it calls its observers with two parameters: 
the `Property`'s widget instance and the changed value. 

A property of a widget is an instance of the `Property` class. 
It is not the Python built-in `property` class that 
is often used with the `@property` decorator. 
The `Property` class implements the observer pattern and 
other special features such as value validation. 

The `Property` class has the following event-related methods: 

* `bind()`: bind a property event to one or more handlers, i.e., bind 
an observer to a value change event. 
* `unbind()`: unbind a handler.
* `dispatch()`: dispatch an event manually. Usually Kivy fires events 
automatically when something happens. But we can fire an event using
this method. 

### Property Classes
The `Property` class is the parent class for a number of type-specific 
property types. This class should not be directly instantiated.
The following are some common property classes that can be 
used to represent type-specific values, valid values and 
fire events when their values change. 

* `NumericProperty`: it represents an `int` or `float` value and a type. 
Default is 0 with a type of `px`. A `NumericProperty` value can be
initialized with a numeric number and a type. For example, 
`0.5`, `'5dp'`, and `(7.5, "sp")` are all valid values.
* `BoundedNumericProperty`: it represents a numeric value that has 
a minimum and/or a maximum bound. 
* `StringProperty`: it represents a string value. Default is an empty
string `''`.
* `ListProperty`: it represents a list. Default is an empty list. 
* `ObjectProperty`: it represents a Python object. It first an event
when it is assigned to a different Python object.
* `BooleanProperty`: it represents a boolean value.
* `OptionProperty`: it represents a string that must be from
a predefined list of strings. 
* `ReferenceListProperty`: it represents a tuple of other properties. 
The `pos` property of a widget is an instance of `ReferenceListProperty`. 
When you read the property, it returns a tuple of Python values. 
* `DictProperty`: it represents a dict. 

Use of property events involves three steps: declare a property, 
change a property value, handle a property event. 

### 1. Property Declaration
A Kivy property must be declared as a class attribute. 
A Kivy property is an instance of the above property classes.
Following is a widget class that has two properties: 

```python
class CustomBtn(Widget):
    pressed = ListProperty([0, 0])
    demo_prop = NumericProperty(0)
```



### 2. Change a Property Value


## Event Dispatcher
All Kivy widget classes are subclasses of the `EventDispatcher` Class.
This class has the following event-related methods:

* `bind()`: bind a widget-defined event to one or more handlers
* `unbind()`: unbind one or more handlers.
* `register_event_type()`: register an event type.
* `unregister_event_types()`: unregister event types.
* `dispatch()`: dispatch (fire) an event. Usually Kivy fires events 
automatically when something happens. But we can fire an event too.
* `events()`: return all events in the class
* `get_property_observers()`: return a list of handlers bound to 
an event (a widget_defined event or a property event)






